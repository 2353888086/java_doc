~~~java
/**
 *
 * 继承
 * JAVA的三大特性：继承 封装 多态
 *
 * 继承的作用：
 *  提高代码的复用，相同代码可以定义在父类
 * 继承特点：
 *  子类继承父类，子类就可以知己得到父类的属性（成员变量）和行为（方法）
 *
 * 子类继承父类，子类不仅包含父类功能，自己可以扩展自己的代码或重写父类方法
 *
 * 子类不能继承类型的方法
 *      子类不能继承类型的构造器，但是子类在实例化时会调用父类的构造器
 *
 * 子类实例化会导致其继承的父类也实例化么？ -不会
 *     类实例化过程：
 *        1.方法区中有Animal和Cat两个class
 *        2.在栈中申请空间，声明引用变量 cat
 *        3.在堆内存中开辟一个内存空间并分配内存地址
 *          new Cat() 内存空间中有两部分 一部分是 super父类对象空间 ，一部分是子类对象空间this
 *        4.对对象的属性进行初始化（包括父类）
 *        5.子类构造方法进栈
 *        6.显式初始化父类属性
 *        7.父类构造方法进栈，执行完出栈
 *        8.显式初始化子类属性
 *        9.初始化结束后，将堆内存中的内存地址赋值给引用变量，然后子类构造方法出栈
 *         子类会分配内存地址，但是父类不会被分配，所以父类没有被初始化
 *
 * 子类是否可以继承父类的私有成员
 *  可以继承父类的私有成员只是不能直接访问，
 *  可以反射暴力的访问父类私有成员
 *
 * 子类是否可以继承父类的静态成员
 *      静态资源只有一份，加载一次，是属于父类，子类是可以共享的
 *
 * 构造方法特点：
 *  子类构造器默认一定会调用父类的无参构造器，在执行子类的构造器
 * 为什么子类构造器会先调用父类的构造器？
 *  子类继承父类，子类就得到了父类的属性和行为（方法）
 *      当调用子类构造器初始化子类对象数据时，必须先调用父类的构造器初始化继承父类的
 *      属性和行为
 *
 *  继承特点：
 *      单继承、多层继承
 *
 *      为什么是单继承
 *          如果继承两个父类，两个父类都有test方法，自乐调用父类test方法只代码无法判断取谁打方法
 */


/**
 * 方法重写
 *   子类重写方法方法名和形参必须保持一致
 *   子类重写方法返回值类型申明必须小于或等于父类的返回值类型范围
 *   子类重写方法修饰符权限必须大于或等于父类修饰符权限
 *   子类重写方法申明抛出的异常应该与父类的异常范围更小或相等
 *
 * 建议重写规范
 *  加上@Override注解
 *  申明不变，重写实现
 *
 *  静态方法和私有方法可以被重写么？
 *  不可以
 *  私有方法是只针对类本身的方法，子类虽然继承但不能访问的，㛑无法重写
 *  静态方式是只有一份的，父类的方法是无法被子类重写，子类写的相同静态方法是子类的静态方式
 *
 *
 */

 /* 1.调用父类构造器是没有创建父类，只执行了一次new指令，用来创建子类对象，
 *  super这个关键字只是访问了这个子类空间特定部分的数据（用来专门存储父类内部数据）
 * 2.成员变量不具有多态，子类是父类的相同描述的成员变量分开存储，互不干扰，也未被覆盖
 *  父类的name和子类的name同一个对象不同存储空间
 *
 * this代表访问了当前对象的引用，可以用于访问当前子类对象的成员变量
 * super代表父类对象的引用
  */
~~~


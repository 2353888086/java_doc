> 面对对象思想

~~~text
面向过程更多是以“执行者”的角度来思考问题分析解决问题的步骤，更多是关注处理的过程，比如说：计算随机数的算法
面向对象更多是以“组织者”的角度来思考问题，把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。比如说：开汽车，我不需要关心是发动机是怎么组装的，我只需要关心发动机能不提供所需动力这个行为就可以了
~~~

> 封装、继承、多态

~~~ java
封装（Encapsulation）是面向对象方法的重要原则，就是把对象的属性和操作（或服务）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。

将类的某些信息隐藏在类的内部，不允许外部程序进行直接的访问调用。
通过该类提供的方法来实现对隐藏信息的操作和访问。隐藏对象的信息。留出访问的对外接口。

封装的特点
​对成员变量实行更准确的控制。
​封装可以隐藏内部程序实现的细节。
​良好的封装能够减少代码之间的耦合度。
​外部成员无法修改已封装好的程序代码。
​方便数据检查，有利于保护对象信息的完整性，同时也提高程序的安全性。
​便于修改，体高代码的可维护性。

继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。当然，如果在父类中拥有私有属性(private修饰)，则子类是不能被继承的。

3.2，继承的特点
   提高代码复用性。父类的属性方法可以用于子类。可以轻松的定义子类。使设计应用程序变得简单。


​ 只支持单继承，即一个子类只允许有一个父类，但是可以实现多级继承，及子类拥有唯一的父类，而父类还可以再继承。
​ 子类可以拥有父类的属性和方法。
​ 子类可以拥有自己的属性和方法。
​ 子类可以重写覆盖父类的方法。
​ 成员方法也是一样的，创建的对象是谁，就优先使用谁，如果没有则直接向上找。
​ 注意事项：
​ 无论是成员变量还是成员方法，如果没有都是向上父类中查找，绝对不会向下查找子类的。

重写(override)是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！

​ 重写的规则：
​ 1，参数列表必须与被重写方法相同。
​ 2，访问权限不能比父类中被重写的方法的访问权限更低（public>protected>(default)>private）。
​ 3，父类成员的方法只能被它的子类重写。
​ 4，被final修饰的方法不能被重写。
​ 5，构造方法不能

重载 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

​ 重载规则：

​ 1，被重载的方法必须改变参数列表（参数个数或者类型不一样）。

​ 2，被重载的方法可以改变返回类型。

​ 3，被重载的方法可以改变访问修饰符。

3.5，this，super关键字
super()关键字的用法
​ 1，子类的成员方法中，访问父类的成员变量。
​ 2，子类的成员方法中，访问父类的成员方法。
​ 3，子类的构造方法中，访问父类的构造方法。

this关键字用法：
​ 1，本类成员方法中，访问本类的成员变量。
​ 2，本类成员方法中，访问本类的另一个成员方法。
3，本类的构造方法中，访问本类的另一个构造方法。
​ 注意：
this关键字同super一样，必须在构造方法的第一个语句，且是唯一的。
this与super不能同时存在。
3.6，构造器
​ 继承关系中，父子类构造方法的访问特点：
​ 1，在子类构造方法中有一个默认隐含的super();调用，因此一定是先调用父类构造方法，再调用子类构造方法。
​ 2，子类构造可以通过super();调用父类的重载构造。(重载)
​ 3，super();的父类调用构造方法，必须在子类构造中的第一行，就是第一个;号结束的元素，并且只能调用一次。

3.7，关于继承的注意事项：
​ 1，Java语言是单继承的，一个子类只能有唯一一个父类
​ 2，Java语言可以是多级继承，一个子类有一个父类，一个父类还可以有一个父类。
​ 3，一个子类只有一个父类，但是一个父类可以有多个子类。



多态 是同一个行为具有多个不同表现形式或形态的能力。

4.2，多态的特点
​ 1，消除类型之间的耦合关系，实现低耦合。
​ 2，灵活性。
​ 3，可扩充性。
​ 4，可替换性。

多态的体现形式继承 : 父类引用指向子类
List a = new ArrayList();

向上转型
1，格式：父类名称 对象名 = new 子类名称(); 
      含义：右侧创建一个子类对象，把它当作父类来使用。
      注意：向上转型一定是安全的。
      缺点：一旦向上转型，子类中原本特有的方法就不能再被调用了。	


五，接口
​ 最后，关于接口方面的细节，不同版本之间的区别。

问题描述：

​ 现在接口中需要抽取一个公有的方法，用来解决默认方法中代码重复的问题。
​ 但是这个共有的方法不能让实现类实现，所以应该设置为私有化。

在JDK8之后：

​ 1，default修饰，接口里允许定义默认的方法，但默认方法也可以覆盖重写。
​ 2，接口里允许定义静态方法。

在JDK9之后：

​ 1，普通私有方法，解决多个默认方法之间代码重复的问题。
​ 2，静态私有化，解决多个静态方法之间代码重复问题。
​ 接口的注意事项：
​ 1，不能通过接口的实现类对象去调用接口中的静态方法。
​ 正确语法：接口名称调用静态方法。

接口当中的常量的使用：

​ 1，接口当中定义的常量：可以省略public static final。
​ 2，接口当中定义的常量：必须进行赋值。
​ 3，接口当中定义的常量：常量的名称要全部大写，多个名称之间使用下划线进行分割。

使用接口的注意事项：

​ 1，接口是没有静态代码块或者构造方法
​ 2，一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。
​ 3，如果实现类没有覆盖重写接口中所有的抽象方法，那么实现类就必须是一个抽象类
​ 4，如果实现类中实现多个接口，存在重复的抽象方法，那么只需要覆盖重写一次即可。
​ 5，在Java中，如果实现类的直接继承父类与实现接口发生冲突时，父类优先级高于接口。

接口之间的关系：

​ 1，多个接口之间是继承关系。
​ 2，多个父接口当中默认方法如果重复，那么子接口必须进行默认方法的覆盖重写。
~~~

> ==和equals的区别

```java
== 比较的是值
比较基本的数据类型，比较的是数值
比较引用类型：比较引用指向的值（地址）

equals
默认比较也是地址，因为这个方法的最初定义在Object上，默认的实现就是比较地址

在方法栈中，
针对基本数据类型是在方法栈中有一块内存保存值，== 针对基本数据类型比较的是 方法栈中的值
引用对象在方法栈有一块内存报错变量，它的值是在堆引用对象的地址， == 在比较引用对象的时候比较就是应用对象的地址是不是同一个，Object上，默认的实现就是比较地址，除非重写了


String s1 = new String("zs");
String s2 = new String("zs");
System.out.println(s1 == s2); false ，不同对象
String s3 = "zs";
String s4 = "zs";
System.out.println(s3 == s4); true ， 常量池中的值
System.out.println(s3 == s1); false ，一个是常量池中的值，一个是对象
String s5 = "zszs";
String s6 = s3+s4;
System.out.println(s5 == s6); false ，s3+s4;创建了新的对象
final String s7 = "zs";
final String s8 = "zs";
String s9 = s7+s8;
System.out.println(s5 == s9);true ，两个常量
final String s10 = s3+s4;
System.out.println(s5 == s10);false ，，s3+s4;创建了新的对象
```

> 接口和抽象类的区别

```text
这个问题，要分JDK版本来区分回答：

JDK1.8之前：
语法：
抽象类：方法可以有抽象的，也可以有非抽象, 有构造器
接口：方法都是抽象，属性都是常量，默认有public static final修饰
设计：
抽象类：同一类事物的抽取，比如针对Dao层操作的封装，如，BaseDao可以将公共的UCRD操作抽取出来，BaseServiceImpl
接口：通常更像是一种标准的制定，定制系统之间对接的标准
例子：
1，单体项目，分层开发，interface作为各层之间的纽带，在controller中注入IUserService，在Service注入IUserDao
2，分布式项目，面向服务的开发，抽取服务service，这个时候，就会产生服务的提供者和服务的消费者两个角色
这两个角色之间的纽带，依然是接口
JDK1.8之后：
接口里面可以有实现的方法，注意要在方法的声明上加上default或者static
最后区分几个概念：

多继承，多重继承，多实现
多重继承：A->B->C（爷孙三代的关系）
多实现：Person implements IRunable,IEatable（符合多项国际化标准）
多继承：接口可以多继承，类只支持单继承
```

> List和Set

~~~java
List底层是数据，所以数据有序的
Set底层是HashMap里的Key，所以是无序且是不可重复的
~~~

> 谈谈ArrayList和LinkedList的区别

~~~java
底层数据结构的差异
ArrayList，数组，连续一块内存空间
LinkedList，双向链表，不是连续的内存空间
~~~

> ArrayList和LinkedList

~~~java
底层数据结构的差异
ArrayList，数组，连续一块内存空间
LinkedList，双向链表，不是连续的内存空间
2，一个常规的结论
虽然不严谨，但也可以应付很多面试了

ArrayList，查找快，因为是连续的内存空间，方便寻址，但删除，插入慢，因为需要发生数据迁移（是说指定位置的查询是很快）
LinkedList，查找慢，因为需要通过指针一个个寻找，但删除，插入块，因为只要改变前后节点的指针指向即可。
3，ArrayList细节分析
1，增加

添加到末尾，正常不需要做特别的处理，除非现有的数组空间不够了，需要扩容
数组初始化容量多大？10，当你知道需要存储多少数据时，建议在创建的时候，直接设置初始化大小
怎么扩容？
当发现容量不够之后，就进行扩容
按原先数组容量的1.5倍进行扩容，位运算，下面是关键的源码
int oldCapacity = elementData.length;
int newCapacity = oldCapacity + (oldCapacity >> 1);
再将原先数组的元素复制到新数组，Arrays
elementData = Arrays.copyOf(elementData, newCapacity)
添加到其他位置，这个时候需要做整体的搬迁
2，删除
删除末尾，并不需要迁移
删除其他的位置，这个时候也需要搬迁
3，修改
修改之前，必须先定位
定位-查找-ArrayList（数组是一段连续的内存空间，定位会特别快）
4，查找
如上所述
4，LinkedList细节分析
1，提供了的两个引用（first，last）

2，增加

添加到末尾，创建一个新的节点，将之前的last节点设置为新节点的pre，新节点设置为last

我们看下源码：

void linkLast(E e) {
    //获取到最后一个节点​
    final Node<E> l = last;
    //构建一个新节点，将当前的last作为这个新节点的pre​
    final Node<E> newNode = new Node<>(l, e, null);
    //把last指向新节点​
    last = newNode;
    //如果原先没有最后一个节点​
    if (l == null)
        //将first指向新节点​
        first = newNode;
    else
        //否则，将原先的last的next指向新节点​
        l.next = newNode;
    size++;
    modCount++;
}
Node节点的定义：内部类
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;
    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
添加到其他位置，这个时候，就需要调整前后节点的引用指向

3，如何去定义一个双向链表的节点，如上述的源码所示

4，修改

修改最后一个节点或者第一个节点，那么就很快（first，last）

修改其他位置，如果是按坐标来定位节点，则会按照二分查找法，源码如下：

if (index < (size >> 1)) {
    Node<E> x = first;
    for (int i = 0; i < index; i++)
        x = x.next;
    return x;
} else {
    Node<E> x = last;
    for (int i = size - 1; i > index; i--)
        x = x.prev;
    return x;
}

5，一个思考题，假如我们可以确定要存储1000个元素，那么采用ArrayList和LinkedList，

哪个更耗内存，为什么？

6，LinkedList，要实现在A和B之间插入C，该如何实现，编写伪代码即可
~~~

